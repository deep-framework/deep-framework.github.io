<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">lib/Resource/Request.js | DEEP Resource Library API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
</head>
<body class="layout-container">

<header>
  <a href="./">Home</a>
  <a href="identifiers.html">Identifier</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/MitocGroup/deep.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource.js~Resource.html">Resource</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Exception</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Exception/Exception.js~Exception.html">Exception</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Exception/MissingResourceException.js~MissingResourceException.html">MissingResourceException</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Resource</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource/Action.js~Action.html">Action</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource/Instance.js~Instance.html">Instance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource/LambdaResponse.js~LambdaResponse.html">LambdaResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource/LocalRequest.js~LocalRequest.html">LocalRequest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource/Request.js~Request.html">Request</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource/Response.js~Response.html">Response</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource/SuperagentResponse.js~SuperagentResponse.html">SuperagentResponse</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Resource/Exception</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource/Exception/CachedRequestException.js~CachedRequestException.html">CachedRequestException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource/Exception/DirectLambdaCallDeniedException.js~DirectLambdaCallDeniedException.html">DirectLambdaCallDeniedException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource/Exception/MissingActionException.js~MissingActionException.html">MissingActionException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource/Exception/MissingCacheImplementationException.js~MissingCacheImplementationException.html">MissingCacheImplementationException</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/Resource/Exception/UnknownMethodException.js~UnknownMethodException.html">UnknownMethodException</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/Resource/Request.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * Created by AlexanderC on 6/10/15.
 */

&apos;use strict&apos;;

import {SuperagentResponse} from &apos;./SuperagentResponse&apos;;
import {LambdaResponse} from &apos;./LambdaResponse&apos;;
import {Response} from &apos;./Response&apos;;
import {Exception} from &apos;../Exception/Exception&apos;;
import {Action} from &apos;./Action&apos;;
import Http from &apos;superagent&apos;;
import AWS from &apos;aws-sdk&apos;;
import {MissingCacheImplementationException} from &apos;./Exception/MissingCacheImplementationException&apos;;
import {CachedRequestException} from &apos;./Exception/CachedRequestException&apos;;
import aws4 from &apos;aws4&apos;;
import parseUrl from &apos;parse-url&apos;;
import queryString from &apos;query-string&apos;;
import Core from &apos;deep-core&apos;;
import {DirectLambdaCallDeniedException} from &apos;./Exception/DirectLambdaCallDeniedException&apos;;

/**
 * Action request instance
 */
export class Request {
  /**
   * @param {Action} action
   * @param {Object} payload
   * @param {String} method
   */
  constructor(action, payload, method) {
    this._action = action;
    this._payload = payload;
    this._method = method;
    this._lambda = null;

    this._cacheImpl = null;
    this._cacheTtl = Request.TTL_FOREVER;
    this._cached = false;

    this._native = true; // @todo: set it to false
  }

  /**
   * @returns {Boolean}
   */
  get native() {
    return this._native;
  }

  /**
   * @returns {Request}
   */
  useDirectCall() {
    if (this._action.forceUserIdentity) {
      throw new DirectLambdaCallDeniedException(this);
    }

    this._native = true;
    return this;
  }

  /**
   * @returns {Boolean}
   */
  get isCached() {
    return this._cacheImpl &amp;&amp; this._cached;
  }

  /**
   * @returns {Request}
   */
  enableCache() {
    this._cached = true;
    return this;
  }

  /**
   * @returns {Request}
   */
  disableCache() {
    this._cached = false;
    return this;
  }

  /**
   * @param {Number} ttl
   * @returns {Request}
   */
  cache(ttl = Request.TTL_FOREVER) {
    if (!this._cacheImpl) {
      throw new MissingCacheImplementationException();
    }

    this._cacheTtl = ttl;
    this.enableCache();

    return this;
  }

  /**
   * @returns {Number}
   */
  get cacheTtl() {
    return this._cacheTtl;
  }

  /**
   * @param {Number} ttl
   */
  set cacheTtl(ttl) {
    this._cacheTtl = ttl;
  }

  /**
   * @returns {Object}
   */
  get cacheImpl() {
    return this._cacheImpl;
  }

  /**
   * @param {Object} cache
   */
  set cacheImpl(cache) {
    this._cacheImpl = cache;

    // @todo: do we really have to force it?
    this.cache(Request.TTL_DEFAULT);
  }

  /**
   * @returns {String}
   * @private
   */
  _buildCacheKey() {
    let payload = JSON.stringify(this._payload);
    let endpoint = this.native ? this._action.source.original : this._action.source.api;

    return `${this._method}:${this._action.type}:${endpoint}#${payload}`;
  }

  /**
   * @param {Response} response
   * @returns {String}
   * @private
   */
  static _stringifyResponse(response) {
    return JSON.stringify({
      _class: response.constructor.name,
      data: response.rawData,
      error: response.rawError,
    });
  }

  /**
   * @param {String} rawData
   * @returns {Response}
   * @private
   */
  _rebuildResponse(rawData) {
    let response = JSON.parse(rawData);

    if (!response) {
      throw new CachedRequestException(`Unable to unpack cached JSON object from ${rawData}`);
    }

    let ResponseImpl = Request._chooseResponseImpl(response._class);

    if (!ResponseImpl) {
      throw new Exception(`Unknown Response implementation ${response._class}`);
    }

    return new ResponseImpl(this, response.data, response.error);
  }

  /**
   * @param {String} className
   * @returns {*}
   * @private
   */
  static _chooseResponseImpl(className) {
    let implMap = {};

    implMap[Response.name] = Response;
    implMap[LambdaResponse.name] = LambdaResponse;
    implMap[SuperagentResponse.name] = SuperagentResponse;

    return implMap[className];
  }

  /**
   * @param {Function} callback
   */
  invalidateCache(callback = null) {
    if (!this.isCached) {
      callback &amp;&amp; callback(true);

      return this;
    }

    let cache = this._cacheImpl;
    let cacheKey = this._buildCacheKey();

    cache.has(cacheKey, function(error, result) {
      if (error) {
        throw new CachedRequestException(error);
      }

      if (result) {
        cache.invalidate(cacheKey, 0, function(error, result) {
          if (error) {
            throw new CachedRequestException(error);
          }

          callback &amp;&amp; callback(result);
        }.bind(this));

        return;
      }

      callback &amp;&amp; callback(true);
    }.bind(this));

    return this;
  }

  /**
   * @param {Function} callback
   */
  send(callback = null) {
    if (!this.isCached) {
      return this._send(callback);
    }

    let cache = this._cacheImpl;
    let invalidateCache = this._cacheTtl === Request.TTL_INVALIDATE;
    let cacheKey = this._buildCacheKey();

    cache.has(cacheKey, function(error, result) {
      if (error) {
        throw new CachedRequestException(error);
      }

      if (result &amp;&amp; !invalidateCache) {
        cache.get(cacheKey, function(error, result) {
          if (error) {
            throw new CachedRequestException(error);
          }

          callback &amp;&amp; callback(this._rebuildResponse(result));
        }.bind(this));

        return;
      }

      //todo -TBD
      this._send(function(response) {
        cache.set(cacheKey, Request._stringifyResponse(response), this._cacheTtl, function(error, result) {
          if (!result) {
            error = `Unable to persist request cache under key ${cacheKey}`;
          }

          if (error) {
            throw new CachedRequestException(error);
          }
        }.bind(this));

        // @todo: do it synchronous?
        callback &amp;&amp; callback(response);
      }.bind(this));
    }.bind(this));

    return this;
  }

  /**
   * @param {Function} callback
   * @returns {Request}
   */
  _send(callback = () =&gt; null) {
    if (!this._native) {
      return this._sendThroughApi(callback);
    }

    switch (this._action.type) {
      case Action.LAMBDA:
        this._sendLambda(callback);
        break;
      case Action.EXTERNAL:
        this._sendExternal(callback);
        break;
      default: throw new Exception(`Request of type ${this._action.type} is not implemented`);
    }

    return this;
  }

  /**
   * @param {Function} callback
   * @returns {Request}
   * @private
   */
  _sendThroughApi(callback = () =&gt; null) {
    let endpoint = this._action.source.api;
    let signedRequest = this._createAws4SignedRequest(
      endpoint, 
      this.method, 
      this.payload
    );

    signedRequest.end(function(error, response) {
      callback(new SuperagentResponse(this, response, error));
    }.bind(this));

    return this;
  }

  /**
   * @param {Function} callback
   * @returns {Request}
   * @private
   */
  _sendLambda(callback = () =&gt; null) {
    // @todo: set retries in a smarter way...
    AWS.config.maxRetries = 3;

    this._lambda = new AWS.Lambda({
      region: this._action.region,
    });

    let invocationParameters = {
      FunctionName: this._action.source.original,
      Payload: JSON.stringify(this.payload),
    };

    this._lambda.invoke(invocationParameters, function(error, data) {
      callback(new LambdaResponse(this, data, error));
    }.bind(this));

    return this;
  }

  /**
   * @param {Function} callback
   * @returns {Request}
   * @private
   */
  _sendExternal(callback = () =&gt; null) {
    Http[this._method.toLowerCase()](this._action.source.original)
      .send(this.payload)
      .end(function(error, response) {
        callback(new SuperagentResponse(this, response, error));
      }.bind(this));

    return this;
  }

  /**
   * @param {String} url
   * @param {String} httpMethod
   * @param {Object} payload
   * @private
   */
  _createAws4SignedRequest(url, httpMethod, payload) {
    let urlParts = parseUrl(url);
    let apiHost = urlParts.resource;
    let apiPath = urlParts.pathname ? urlParts.pathname : &apos;/&apos;;
    let apiQueryString = urlParts.search ? `?${urlParts.search}` : &apos;&apos;;

    let opsToSign = {
      service: Core.AWS.Service.API_GATEWAY,
      region: this.getEndpointHostRegion(apiHost),
      host: apiHost,
      method: httpMethod,
      path: `${apiPath}${apiQueryString}`,
      headers: {
        &apos;Content-Type&apos;: &apos;application/json&apos;,
      },
    };

    httpMethod = httpMethod.toLowerCase();
    switch (httpMethod) {
      case &apos;get&apos;:
      case &apos;delete&apos;:
        opsToSign.path += (apiQueryString ? &apos;&amp;&apos; : &apos;?&apos;) + queryString.stringify(payload);
        break;
      case &apos;post&apos;:
      case &apos;put&apos;:
      case &apos;patch&apos;:
        opsToSign.body = JSON.stringify(payload);
        break;
    }

    let signature = aws4.sign(opsToSign, this._getSecurityCredentials());

    let request = Http[httpMethod](url, payload)
      .set(&apos;Content-Type&apos;, &apos;application/json&apos;)
      .set(&apos;X-Amz-Date&apos;, signature.headers[&apos;X-Amz-Date&apos;])
      .set(&apos;X-Amz-Security-Token&apos;, signature.headers[&apos;X-Amz-Security-Token&apos;])
      .set(&apos;Authorization&apos;, signature.headers.Authorization);

    return request;
  }

  /**
   * @returns {Object}
   * @private
   */
  _getSecurityCredentials() {
    return this._action.resource.securityCredentials;
  }

  /**
   * @param {String} endpointHost
   * @returns {String}
   */
  getEndpointHostRegion(endpointHost) {
    let regionParts = endpointHost.match(/\.([^\.]+)\.amazonaws\.com$/i);

    // @todo - expose API region into config provision section
    return regionParts ? regionParts[1] : this._action.region; // use action region as fallback
  }

  /**
   * @returns {Action}
   */
  get action() {
    return this._action;
  }

  /**
   * @returns {Object}
   */
  get payload() {
    return this._payload;
  }

  /**
   * @returns {String}
   */
  get method() {
    return this._method;
  }

  /**
   * @returns {Number}
   * @constructor
   */
  static get TTL_DEFAULT() {
    return 10;
  }

  /**
   * @returns {Number}
   */
  static get TTL_INVALIDATE() {
    return -1;
  }

  /**
   * @returns {Number}
   */
  static get TTL_FOREVER() {
    return 0;
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.3.1)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
